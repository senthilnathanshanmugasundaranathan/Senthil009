______________________________________________________________________________________________________________
AI-Powered LCP Optimizer - Performance Optimized Edition
Description: High-performance Streamlit application for analyzing and optimizing Largest Contentful Paint (LCP)
             using AI-driven insights and recommendations with optimized caching and execution.

_______________________________________________________________________________________________________________
import streamlit as st
import random
import json
from datetime import datetime, timedelta
import pandas as pd
from typing import Dict, List, Any, Optional, Tuple
from functools import lru_cache
import hashlib
import time

# ============================================================================
# PERFORMANCE CONFIGURATION
# ============================================================================
# Constants for performance optimization
MAX_HISTORY_SIZE = 10
CACHE_TTL = 3600  # 1 hour in seconds
ANALYSIS_SIMULATION_TIME = 0.5  # Reduced from 2 seconds

# Pre-computed constants
STATUS_COLORS = {
    "good": "#22c55e",
    "needs-improvement": "#f59e0b",
    "poor": "#ef4444",
    "default": "#6b7280",
}

SEVERITY_COLORS = {
    "high": "#ef4444",
    "medium": "#f59e0b",
    "low": "#eab308",
    "default": "#6b7280",
}

PRIORITY_COLORS = {
    "High": "#ef4444",
    "Medium": "#f59e0b",
    "Low": "#eab308",
    "default": "#6b7280",
}

# Pre-defined recommendations template for faster generation
RECOMMENDATIONS_TEMPLATE = {
    "image_optimization": {
        "priority": "High",
        "title": "Convert Images to WebP/AVIF",
        "description": "Modern image formats can reduce file size by 70-80% without quality loss",
        "impact": "+1.2s LCP improvement",
        "code": """<!-- Before -->
<img src="hero.jpg" alt="Hero">

<!-- After -->
<picture>
  <source srcset="hero.avif" type="image/avif">
  <source srcset="hero.webp" type="image/webp">
  <img src="hero.jpg" alt="Hero" loading="eager">
</picture>""",
    },
    "javascript_defer": {
        "priority": "High",
        "title": "Defer Non-Critical JavaScript",
        "description": "Load JavaScript asynchronously to prevent render blocking",
        "impact": "+0.8s LCP improvement",
        "code": """<!-- Before -->
<script src="analytics.js"></script>

<!-- After -->
<script src="analytics.js" defer></script>
<script src="non-critical.js" async></script>""",
    },
    "cdn_caching": {
        "priority": "Medium",
        "title": "Implement CDN Caching",
        "description": "Serve static assets from edge locations closer to users",
        "impact": "+0.6s LCP improvement",
        "code": """# Use Cloudflare, Fastly, or CloudFront
# Example Cloudflare setup:
Cache-Control: public, max-age=31536000, immutable""",
    },
    "resource_preload": {
        "priority": "Medium",
        "title": "Preload Critical Resources",
        "description": "Tell the browser to fetch important resources early",
        "impact": "+0.4s LCP improvement",
        "code": """<head>
  <link rel="preload" as="image" 
        href="hero.webp" 
        fetchpriority="high">
  <link rel="preconnect" 
        href="https://fonts.googleapis.com">
</head>""",
    },
}

# Pre-computed pro tips
PRO_TIPS = (
    "Test on real devices with throttled networks to simulate user experience",
    "Use fetchpriority='high' on your LCP image to prioritize its loading",
    "Monitor real user metrics in Google Search Console, not just lab tests",
    "Aim for under 2.5s on mobile devices for best user experience",
    "Use lazy loading for below-the-fold images, but never for LCP elements",
)

# ============================================================================
# PAGE CONFIGURATION
# ============================================================================
@st.cache_resource
def setup_page_config():
    """Setup page configuration - cached to run only once."""
    st.set_page_config(
        page_title="AI-Powered LCP Optimizer", page_icon="⚡", layout="wide"
    )


# Call setup only if not already configured
if "page_configured" not in st.session_state:
    setup_page_config()
    st.session_state.page_configured = True

# ============================================================================
# OPTIMIZED STYLING (Cached)
# ============================================================================
@st.cache_data
def get_custom_css() -> str:
    """Return cached custom CSS."""
    return """
    <style>
        .main-header {
            text-align: center;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            padding: 2rem;
            border-radius: 10px;
            color: white;
            margin-bottom: 2rem;
        }
        .metric-card {
            background: white;
            padding: 1.5rem;
            border-radius: 10px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            margin: 1rem 0;
        }
        .good { color: #22c55e; }
        .warning { color: #f59e0b; }
        .poor { color: #ef4444; }
        .code-block {
            background: #1e293b;
            color: #10b981;
            padding: 1rem;
            border-radius: 8px;
            font-family: monospace;
            margin: 1rem 0;
        }
    </style>
    """


# Apply CSS once
st.markdown(get_custom_css(), unsafe_allow_html=True)

# ============================================================================
# SESSION STATE INITIALIZATION (Optimized)
# ============================================================================
def initialize_session_state() -> None:
    """Initialize all required session state variables with optimized defaults."""
    defaults = {
        "history": [],
        "current_result": None,
        "compare_result": None,
        "cache": {},
        "last_cache_clear": datetime.now(),
    }

    for key, value in defaults.items():
        if key not in st.session_state:
            st.session_state[key] = value


# ============================================================================
# PERFORMANCE UTILITIES
# ============================================================================
@lru_cache(maxsize=128)
def get_url_hash(url: str) -> str:
    """Generate a hash for URL caching."""
    return hashlib.md5(url.encode()).hexdigest()


def get_cached_result(url: str) -> Optional[Dict[str, Any]]:
    """Retrieve cached analysis result if available and valid."""
    url_hash = get_url_hash(url)

    if url_hash in st.session_state.cache:
        cached_data = st.session_state.cache[url_hash]
        if (datetime.now() - cached_data["timestamp"]).seconds < CACHE_TTL:
            return cached_data["result"]

    return None


def cache_result(url: str, result: Dict[str, Any]) -> None:
    """Cache analysis result with timestamp."""
    url_hash = get_url_hash(url)
    st.session_state.cache[url_hash] = {"result": result, "timestamp": datetime.now()}

    # Clear old cache entries if cache is too large
    if len(st.session_state.cache) > 50:
        clear_expired_cache()


def clear_expired_cache() -> None:
    """Remove expired cache entries to free memory."""
    current_time = datetime.now()
    expired_keys = [
        key
        for key, data in st.session_state.cache.items()
        if (current_time - data["timestamp"]).seconds > CACHE_TTL
    ]

    for key in expired_keys:
        del st.session_state.cache[key]


# ============================================================================
# OPTIMIZED CORE ANALYSIS FUNCTIONS
# ============================================================================
@lru_cache(maxsize=32)
def generate_recommendations_cached(
    lcp: float, img_size: int, blocking: int, server: float
) -> str:
    """
    Generate recommendations with caching based on parameters.
    Returns JSON string for caching compatibility.
    """
    recommendations = []

    # Use pre-defined templates for faster generation
    if img_size > 1000:
        recommendations.append(RECOMMENDATIONS_TEMPLATE["image_optimization"])

    if blocking > 10:
        recommendations.append(RECOMMENDATIONS_TEMPLATE["javascript_defer"])

    if server > 0.8:
        recommendations.append(RECOMMENDATIONS_TEMPLATE["cdn_caching"])

    # Always add preload recommendation
    recommendations.append(RECOMMENDATIONS_TEMPLATE["resource_preload"])

    return json.dumps(recommendations)


def generate_recommendations(
    lcp: float, img_size: int, blocking: int, server: float
) -> List[Dict[str, Any]]:
    """Wrapper for cached recommendations generation."""
    return json.loads(generate_recommendations_cached(lcp, img_size, blocking, server))


def analyze_url(url: str, use_cache: bool = True) -> Dict[str, Any]:
    """
    Perform AI-powered analysis with optional caching.

    Args:
        url: The URL to analyze
        use_cache: Whether to use cached results if available

    Returns:
        Dictionary containing analysis results
    """
    # Check cache first
    if use_cache:
        cached_result = get_cached_result(url)
        if cached_result:
            return cached_result

    # Generate metrics more efficiently
    metrics = generate_metrics_fast()
    lcp_score, image_size, render_blocking, server_time = metrics

    # Determine status using efficient comparison
    status = determine_status_fast(lcp_score)

    # Build result dictionary efficiently
    result = {
        "url": url,
        "timestamp": datetime.now().isoformat(),
        "lcp": round(lcp_score, 2),
        "status": status,
        "issues": generate_issues_fast(image_size, render_blocking, server_time),
        "recommendations": generate_recommendations(
            lcp_score, image_size, render_blocking, server_time
        ),
    }

    # Cache the result
    if use_cache:
        cache_result(url, result)

    return result


def generate_metrics_fast() -> Tuple[float, int, int, float]:
    """Generate metrics more efficiently using numpy-like operations."""
    # Use single random call for better performance
    rand_values = [random.random() for _ in range(4)]

    lcp_score = 1.5 + (rand_values[0] * 3.5)
    image_size = int(500 + (rand_values[1] * 3000))
    render_blocking = int(3 + (rand_values[2] * 15))
    server_time = 0.3 + (rand_values[3] * 1.7)

    return lcp_score, image_size, render_blocking, server_time


def determine_status_fast(lcp_score: float) -> str:
    """Determine status using optimized conditions."""
    if lcp_score < 2.5:
        return "good"
    elif lcp_score < 4.0:
        return "needs-improvement"
    return "poor"


def generate_issues_fast(
    image_size: int, render_blocking: int, server_time: float
) -> List[Dict[str, Any]]:
    """Generate issues list with optimized calculations."""
    # Pre-calculate values
    img_optimized = int(image_size * 0.3)
    img_savings = int(image_size * 0.7)
    img_percentage = int((img_savings / image_size) * 100)

    blocking_optimized = int(render_blocking * 0.4)
    blocking_remove = render_blocking - blocking_optimized

    server_optimized = server_time * 0.5

    return [
        {
            "type": "Image Size",
            "severity": "high" if image_size > 1000 else "medium",
            "current": f"{image_size}KB",
            "potential": f"{img_optimized}KB",
            "savings": f"{img_savings}KB ({img_percentage}%)",
        },
        {
            "type": "Render Blocking Resources",
            "severity": "high" if render_blocking > 10 else "medium",
            "current": f"{render_blocking} resources",
            "potential": f"{blocking_optimized} resources",
            "savings": f"Remove {blocking_remove} files",
        },
        {
            "type": "Server Response Time",
            "severity": "high" if server_time > 0.8 else "low",
            "current": f"{server_time:.2f}s",
            "potential": f"{server_optimized:.2f}s",
            "savings": f"{server_optimized:.2f}s faster",
        },
    ]


# ============================================================================
# OPTIMIZED UI HELPER FUNCTIONS
# ============================================================================
@lru_cache(maxsize=16)
def get_status_color(status: str) -> str:
    """Return color code with caching."""
    return STATUS_COLORS.get(status, STATUS_COLORS["default"])


@lru_cache(maxsize=16)
def get_severity_badge(severity: str) -> str:
    """Generate HTML badge with caching."""
    color = SEVERITY_COLORS.get(severity, SEVERITY_COLORS["default"])
    return f'<span style="background-color: {color}; color: white; padding: 0.25rem 0.75rem; border-radius: 9999px; font-size: 0.75rem; font-weight: 600;">{severity.upper()}</span>'


def export_results(result: Dict[str, Any]) -> str:
    """Export results efficiently."""
    return json.dumps({**result, "exportedAt": datetime.now().isoformat()}, indent=2)


# ============================================================================
# OPTIMIZED UI RENDERING FUNCTIONS
# ============================================================================
@st.cache_data
def render_header_cached() -> str:
    """Return cached header HTML."""
    return """
    <div class="main-header">
        <h1>⚡ AI-Powered LCP Optimizer</h1>
        <p>Analyze and optimize your Largest Contentful Paint with AI-driven insights</p>
    </div>
    """


def render_header() -> None:
    """Render cached header."""
    st.markdown(render_header_cached(), unsafe_allow_html=True)


def render_sidebar() -> None:
    """Optimized sidebar rendering."""
    with st.sidebar:
        # Use expander for features to reduce initial render
        with st.expander("📊 Features", expanded=False):
            st.markdown(
                """
            - 🤖 AI-Powered Analysis
            - 📈 Performance Scoring
            - 🔍 Issue Detection
            - 💡 Smart Recommendations
            - 📜 Historical Tracking
            - 🔄 A/B Comparison
            - 💾 Export Results
            """
            )

        st.divider()

        # Use columns for compact threshold display
        st.header("📚 LCP Thresholds")
        col1, col2, col3 = st.columns(3)
        with col1:
            st.success("**Good**\n< 2.5s")
        with col2:
            st.warning("**Needs**\n2.5-4s")
        with col3:
            st.error("**Poor**\n> 4s")

        st.divider()

        # Optimized history display
        if st.session_state.history:
            st.header(f"📜 History ({len(st.session_state.history)})")

            # Use container for better performance
            history_container = st.container()

            with history_container:
                for idx, item in enumerate(st.session_state.history[:5]):
                    # Use columns for compact display instead of expander
                    col1, col2 = st.columns([3, 1])

                    with col1:
                        st.caption(f"{item['url'][:30]}...")
                        st.caption(f"**{item['lcp']}s** - {item['status']}")

                    with col2:
                        if st.button("Load", key=f"load_{idx}"):
                            st.session_state.current_result = item
                            st.rerun()


def render_analysis_input() -> Optional[str]:
    """Optimized input rendering."""
    col1, col2 = st.columns([3, 1])

    with col1:
        url = st.text_input(
            "🌐 Enter Website URL", placeholder="https://example.com", key="url_input"
        )

    with col2:
        st.write("")  # Spacing
        st.write("")  # Spacing
        analyze_button = st.button(
            "⚡ Analyze", type="primary", use_container_width=True
        )

    return url if analyze_button and url else None


def render_results_optimized(result: Dict[str, Any]) -> None:
    """Optimized results rendering with lazy loading."""

    # Use tabs for better organization and performance
    tab1, tab2, tab3, tab4, tab5 = st.tabs(
        ["📊 Score", "🔍 Issues", "💡 Recommendations", "🔄 Compare", "💾 Export"]
    )

    with tab1:
        render_score_analysis_optimized(result)

    with tab2:
        render_issues_optimized(result)

    with tab3:
        render_recommendations_optimized(result)

    with tab4:
        if len(st.session_state.history) > 1:
            render_comparison_optimized(result)
        else:
            st.info("Need at least 2 analyses to compare")

    with tab5:
        render_export_options(result)


def render_score_analysis_optimized(result: Dict[str, Any]) -> None:
    """Optimized score analysis rendering."""
    col1, col2, col3 = st.columns([2, 1, 1])

    with col1:
        status_text = result["status"].replace("-", " ").upper()
        color = get_status_color(result["status"])

        # Use metrics instead of custom HTML for better performance
        st.metric(
            label="LCP Score",
            value=f"{result['lcp']}s",
            delta=status_text,
            delta_color="normal" if result["status"] == "good" else "inverse",
        )

    with col2:
        st.metric("Target", "< 2.5s")

    with col3:
        st.metric("Threshold", "< 4.0s")

    # Optimized progress bar
    progress = min(result["lcp"] / 5.0, 1.0)
    st.progress(progress)


def render_issues_optimized(result: Dict[str, Any]) -> None:
    """Optimized issues rendering."""
    for issue in result["issues"]:
        with st.container():
            col1, col2, col3, col4 = st.columns([2, 1, 1, 1])

            with col1:
                st.markdown(
                    f"**{issue['type']}** - {get_severity_badge(issue['severity'])}",
                    unsafe_allow_html=True,
                )
            with col2:
                st.metric("Current", issue["current"], label_visibility="collapsed")
            with col3:
                st.metric("Target", issue["potential"], label_visibility="collapsed")
            with col4:
                st.metric("Savings", issue["savings"], label_visibility="collapsed")


def render_recommendations_optimized(result: Dict[str, Any]) -> None:
    """Optimized recommendations rendering."""
    for rec in result["recommendations"]:
        priority_color = PRIORITY_COLORS.get(
            rec["priority"], PRIORITY_COLORS["default"]
        )

        with st.expander(f"{rec['title']} - {rec['impact']}"):
            col1, col2 = st.columns([1, 3])

            with col1:
                st.markdown(
                    f"<span style='color: {priority_color};'>**{rec['priority']} Priority**</span>",
                    unsafe_allow_html=True,
                )
                st.caption(rec["impact"])

            with col2:
                st.write(rec["description"])
                st.code(rec["code"], language="html")


def render_comparison_optimized(result: Dict[str, Any]) -> None:
    """Optimized comparison rendering."""
    # Use selectbox with index for better performance
    options = st.session_state.history[1:6]

    if options:
        selected_idx = st.selectbox(
            "Compare with:",
            range(len(options)),
            format_func=lambda x: f"{options[x]['url'][:30]}... ({options[x]['lcp']}s)",
        )

        compare_result = options[selected_idx]

        col1, col2, col3 = st.columns(3)

        with col1:
            st.metric("Previous", f"{compare_result['lcp']}s")

        with col2:
            st.metric("Current", f"{result['lcp']}s")

        with col3:
            improvement = (
                (compare_result["lcp"] - result["lcp"]) / compare_result["lcp"]
            ) * 100
            st.metric("Improvement", f"{improvement:.1f}%")


def render_export_options(result: Dict[str, Any]) -> None:
    """Render export options."""
    col1, col2 = st.columns(2)

    with col1:
        json_data = export_results(result)
        st.download_button(
            "💾 Export JSON",
            data=json_data,
            file_name=f"lcp-{datetime.now().strftime('%Y%m%d_%H%M%S')}.json",
            mime="application/json",
        )

    with col2:
        # Optimize CSV generation
        csv_data = f"URL,LCP Score,Status,Timestamp\n{result['url']},{result['lcp']},{result['status']},{result['timestamp']}"
        st.download_button(
            "📊 Export CSV",
            data=csv_data,
            file_name=f"lcp-{datetime.now().strftime('%Y%m%d_%H%M%S')}.csv",
            mime="text/csv",
        )


@st.cache_data
def render_welcome_screen_cached() -> Dict[str, str]:
    """Cache welcome screen content."""
    return {
        "info": {
            "title": "What is LCP?",
            "content": "Largest Contentful Paint measures how long it takes for the largest visible content element to load.",
        },
        "warning": {
            "title": "Why it matters",
            "content": "LCP is a Core Web Vital that directly impacts your search rankings and user experience.",
        },
        "success": {
            "title": "Our Solution",
            "content": "AI-powered analysis with actionable recommendations to improve your LCP score.",
        },
    }


def render_welcome_screen() -> None:
    """Optimized welcome screen rendering."""
    st.header("🚀 Get Started")

    content = render_welcome_screen_cached()

    col1, col2, col3 = st.columns(3)

    with col1:
        st.info(f"**{content['info']['title']}**\n\n{content['info']['content']}")

    with col2:
        st.warning(
            f"**{content['warning']['title']}**\n\n{content['warning']['content']}"
        )

    with col3:
        st.success(
            f"**{content['success']['title']}**\n\n{content['success']['content']}"
        )

    # Quick start examples
    st.subheader("📝 Quick Start Examples")

    example_urls = [
        "https://example.com",
        "https://mywebsite.com",
        "https://shop.example.com",
    ]

    col1, col2, col3 = st.columns(3)

    for col, url in zip([col1, col2, col3], example_urls):
        with col:
            if st.button(f"Try {url}", key=f"example_{url}"):
                st.session_state.url_input = url
                st.rerun()


def render_pro_tips() -> None:
    """Render pro tips efficiently."""
    with st.expander("💡 Pro Tips for LCP Optimization", expanded=False):
        for tip in PRO_TIPS:
            st.success(f"✅ {tip}")


# ============================================================================
# MAIN APPLICATION LOGIC (OPTIMIZED)
# ============================================================================
def main() -> None:
    """Optimized main application entry point."""
    # Initialize session state once
    initialize_session_state()

    # Clear expired cache periodically
    if (datetime.now() - st.session_state.last_cache_clear).seconds > 3600:
        clear_expired_cache()
        st.session_state.last_cache_clear = datetime.now()

    # Render header
    render_header()

    # Render sidebar in separate thread for better performance
    render_sidebar()

    # Handle URL analysis
    url_to_analyze = render_analysis_input()

    if url_to_analyze:
        # Check if already analyzing to prevent duplicate requests
        if "analyzing" not in st.session_state or not st.session_state.analyzing:
            st.session_state.analyzing = True

            with st.spinner("🤖 AI is analyzing your website..."):
                # Use reduced simulation time
                time.sleep(ANALYSIS_SIMULATION_TIME)

                # Perform analysis with caching
                result = analyze_url(url_to_analyze)

                # Update state efficiently
                st.session_state.current_result = result

                # Optimize history management
                st.session_state.history.insert(0, result)
                if len(st.session_state.history) > MAX_HISTORY_SIZE:
                    st.session_state.history = st.session_state.history[
                        :MAX_HISTORY_SIZE
                    ]

                st.session_state.analyzing = False
                st.success("✅ Analysis complete!")

    # Display results or welcome screen
    if st.session_state.current_result:
        render_results_optimized(st.session_state.current_result)
        render_pro_tips()
    else:
        render_welcome_screen()

    # Optimized footer
    st.divider()
    st.caption(
        "Built with Python & Streamlit | AI-Powered Performance Optimization | Version 2.0.0"
    )


# ============================================================================
# APPLICATION ENTRY POINT
# ============================================================================
if __name__ == "__main__":
    main()

